
---@alias event_type "PowerCast"|"Death"|"SpecialActivated"|"GameTick"|"ChatMsg"|"DungeonDestroyed"|"TrapPlaced"

---@class Trigger
---@field conditions function[]|string[]|nil
---@field action function|string
---@field event event_type
---@field triggerData table


require "debug"

--- @param func function|string
local function validatefunc(func)
    if type(func) == "function" then
        if debug.getupvalue(func, 1) ~= nil then
            local n, v = debug.getupvalue(func, 1)
            error("upvalue " .. n .. " found, functions may not contain upvalues, avoid accessing vars local to the file, alternatively pass function name as a string")
        end

    elseif type(func) == "string" then
        if _G[func] == nil then
            error("function '" .. func .."' not found, make sure it is defined globally")
        end
    else
        error("param not a function but " .. type(func))
    end

end

--- Creates a new trigger and returns it
---@param event event_type
---@param action function|string
---@param triggerData? table
---@return table
function CreateTrigger(event,action,triggerData)
    validatefunc(action)
    Game.triggers = Game.triggers or {}
    local trigger = { event = event, conditions = {}, action = action, triggerData = triggerData }
    table.insert(Game.triggers, trigger)
    return trigger
end

--- Adds a condition function that needs to evaluate to true for the actions to be triggered when the event happens
--- @param trigger Trigger
--- @param condition function|string Function that returns true or false
function TriggerAddCondition(trigger, condition)
    validatefunc(condition)
    trigger.conditions = trigger.conditions or {}
    table.insert(trigger.conditions, condition)
end

---@param func function|string
local function pfunc(func,eventData,triggerData)
    if type(func) == "function" then
        return pcall(func,eventData,triggerData)
    elseif type(func) == "string" then
        return pcall(_G[func],eventData,triggerData)
    end
end

--- Processes a trigger
--- @param trigger Trigger The trigger to process
--- @param eventData table The data generated by the event
--- @param errors table A table to store errors in
local function ProcessTrigger(trigger,eventData, errors)
    local allConditionsMet = true
    if trigger.conditions then
        for _, condition in ipairs(trigger.conditions) do
            local success, val = pfunc(condition,eventData,trigger.triggerData)
            if ( success == false) then
                --condition errored out, assume it'll never be true again, and destroy the trigger
                trigger.triggerData.destroyAfterUse = true
                return true
            
            elseif val == false then
                allConditionsMet = false
                break
            end
        end
    end
    if allConditionsMet then
        local success, error = pfunc(trigger.action,eventData,trigger.triggerData)
        if not success then
            errors.insert(error)
        end
        return true
    end
    return false
end

--- goes trough all triggers and checks if they have an event that matches the eventType
--- @param eventType event_type
--- @param eventData table
local function ProcessEvent(eventType, eventData)
    Game.triggers = Game.triggers or {}
    local errors = {}

    --go backwards to allow removing triggers
    for i = #Game.triggers, 1, -1 do
        local trigger = Game.triggers[i]
        if trigger.event == eventType then
            if ProcessTrigger(trigger, eventData, errors) then
                if trigger.triggerData.destroyAfterUse == true then
                    table.remove(Game.triggers, i) -- Remove the trigger safely
                end
            end
        end
    end
    if #errors > 0 then
        for _, error in ipairs(errors) do
            print("Error in trigger: " .. error)
        end
        error(#errors .. " error(s) in triggers of event " .. eventType)
    end
end

---------------------------------------------------------------------------------

--- Called when a spell is cast on a unit
--- @param pwkind power_kind
--- @param caster Player
--- @param target_thing Creature
--- @param stl_x integer
--- @param stl_y integer
--- @param splevel integer
function OnPowerCast(pwkind, caster, target_thing, stl_x, stl_y, splevel)
    local eventData = {}
    eventData.Thing = target_thing
    eventData.PowerKind = pwkind
    eventData.Player = caster
    eventData.stl_x = stl_x
    eventData.stl_y = stl_y
    eventData.splevel = splevel
    ProcessEvent("PowerCast",eventData)
end

--- Called when a unit dies
--- @param unit Creature The unit that dies
function OnUnitDeath(unit)
    local eventData = {}
    eventData.Thing = unit
    ProcessEvent("Death",eventData)
end

--- Called on each game tick to process timer events
function OnGameTick()
    local eventData = {}
    eventData.CurrentTurn = PLAYER0.GAME_TURN
    ProcessEvent("GameTick",eventData)
end

--- Called when a special box is activated
--- @param player Player
--- @param crate_thing Thing
function OnSpecialActivated(player,crate_thing,special_box_id)
    local eventData = {}
    eventData.Thing = crate_thing
    eventData.Player = player
    eventData.SpecialBoxId = special_box_id
    ProcessEvent("SpecialActivated",eventData)
end

--- @param player Player
--- @param message string
function OnChatMsg(player,message)
    local eventData = {}
    eventData.Player = player
    eventData.Message = message
    ProcessEvent("ChatMsg",eventData)
end

--- @param trap Thing The newly placed trap
function OnTrapPlaced(trap)
    local eventData = {}
    eventData.Trap = trap
    ProcessEvent("TrapPlaced",eventData)
end






-----------------------------------------------------------------------------------------------






---
---@param action function|string the function to call when the event happens
---@param SpecialBoxId? integer
---@return Trigger
function RegisterSpecialActivatedEvent(action,SpecialBoxId)
    local trigData = {SpecialBoxId = SpecialBoxId}
    local trigger = CreateTrigger("SpecialActivated",action,trigData)
    if SpecialBoxId then
        TriggerAddCondition(trigger, function(eventData,triggerData) return eventData.SpecialBoxId == triggerData.SpecialBoxId end)
    end
    return trigger
end

---
---@param action function|string the function to call when the event happens
---@param time integer amount of gameticks (1/20 s)
---@param periodic boolean whether the trigger should activate once, or repeat every 'time' gameticks
---@return Trigger
function RegisterTimerEvent(action, time, periodic)
    local trigData = {creationTurn = PLAYER0.GAME_TURN, time = time}
    local trigger = CreateTrigger("GameTick",action,trigData)
    if periodic then
        TriggerAddCondition(trigger, function(eventData,triggerData) return ((eventData.CurrentTurn ~= triggerData.creationTurn) and (eventData.CurrentTurn - triggerData.creationTurn) % triggerData.time == 0) end)
    else
        TriggerAddCondition(trigger, function(eventData,triggerData) return (eventData.CurrentTurn == (triggerData.creationTurn + triggerData.time)) end)
    end

    return trigger
end

---triggers once as soon as the given condition evaluates to true, checked once per gametick
---@param action function|string the function to call when the event happens
---@param condition function|string the condition that needs to be true for the action to be triggered
---@return Trigger
function RegisterOnConditionEvent(action, condition)
    local trigData = {destroyAfterUse = true}
    local trigger = CreateTrigger("GameTick",action,trigData)
    TriggerAddCondition(trigger, condition)
    return trigger
end

---@param action function|string the function to call when the event happens
---@param powerKind? power_kind the spell type that triggers the event
---@return Trigger
function RegisterPowerCastEvent(action,powerKind)
    local trigData = {PowerKind = powerKind}
    local trigger = CreateTrigger("PowerCast",action,trigData)
    if powerKind then
        TriggerAddCondition(trigger, function(eventData,triggerData) return eventData.PowerKind == triggerData.PowerKind end)
    end
    return trigger
end

---@param action function|string the function to call when the event happens
---@param player Player the function to call when the event happens
---@return Trigger
function RegisterDungeonDestroyedEvent(action,player)
    local trigData = {Player = player}
    local trigger = CreateTrigger("DungeonDestroyed",action,trigData)
    if player then
        TriggerAddCondition(trigger, function(eventData,triggerData) return eventData.player == triggerData.player end)
    end
    return trigger
end

function RegisterTrapPlacedEvent(action)
    local trigData = {}
    local trigger = CreateTrigger("TrapPlaced",action,trigData)
    return trigger
    
end



---functions like the IF_ACTION_POINT in dkscript
---can be reset with the resetActionPoint script
---@param action function|string the function to call when the event happens
---@param actionPoint actionpoint the action point that triggers the event
---@return Trigger
function RegisterOnActionPointEvent(action, actionPoint, player)
    local trigData = {Player = player,actionPoint = actionPoint, triggered = false}

    local trigger = CreateTrigger("GameTick",action,trigData)
    TriggerAddCondition(trigger, function(eventData,triggerData)  
                                        if triggerData.triggered == false then
                                            triggerData.triggered = isActionPointActivatedByPlayer(triggerData.Player,triggerData.actionPoint)
                                            return triggerData.triggered
                                        -- make the trigger resettable
                                        elseif isActionPointActivatedByPlayer(triggerData.Player,triggerData.actionPoint) == false then
                                            triggerData.triggered = false
                                            return false
                                        else
                                            return false
                                        end
                                  end )

    return trigger
end

--function Thing:RegisterSpecialActivatedEvent(action) 
--    local trigger = CreateTrigger()
--    TriggerRegisterThingEvent(trigger, nil, "SpecialActivated")
--    TriggerAddCondition(trigger, function() return self == GetTriggeringThing() end)
--    TriggerAddAction(trigger, action)
--end

--TimerEvents
--  periodic or not
--PlayerEvents
--  "Win"|"Lose"|"AlliesChange"
--SlabEvent
--  "OwnerChange"|"TypeChange"

--ThingEvents
--  "powerCast"|"dies"|"SpecialActivated" --|"healthChange"|"happinessChange"|"stateChange"
--TrapEvents
--  "Placed"|"triggered"|"depleted"